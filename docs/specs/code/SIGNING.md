# Abstract

Private keys can be used to sign arbitrary data. If you have the public key, you can verify the data was signed by the owner of the private key. This is how transaction signing works internally but its utility is not limited to transactions. This document tries to set a standard for how to represent and verify signed messages for Cardano.

# Motivation

Most common use cases:

1) Proving ownership of an address/funds
1) Proving ownership of addresses used in a transaction
1) Proving owernship of an identity or other off-chain data with a public key attached to it

# Background

We make use of the following existing work

### Cryptography

Cardano already allows message signing within the WASM bindings. Notably,

1) [sign](https://github.com/input-output-hk/js-cardano-wasm/blob/master/cardano-wallet/src/lib.rs#L177)
2) [verify](https://github.com/input-output-hk/js-cardano-wasm/blob/master/cardano-wallet/src/lib.rs#L232)

You can see an example of these two functions [here](https://repl.it/repls/GlossyDarkgreenMethod)

### Known complexities

Even if you use cryptographically sound `sign` and `verify` functions, you still have the following problems:

1) No human-recognizable prefix
0) No error detection
0) User could accidentally sign a transaction or a block thinking it's harmless data

We also have a risk of a few different kinds of replay attacks

4) A dapp asks person A to sign "BOB" and then another dapp asks user B to sign "BOB". B can just use the signature from A
0) A dapp asks person A to sign "BOB" on testnet chain. Person B then sends this signed message to the same dapp running on mainnet (same argument applies to sidechains)

Additionally, signing for hardware wallets has additional difficulties such as

6) User needs to be able to verify input & output data on device
0) Device has limited memory to store input data

### Other standards

Other blockchains have existing specifications for message signing, but they mostly revolve around scripts trying to validate messages. We don't leverage any of their work in particular but it may be of interest.

- [BIP-137](https://github.com/bitcoin/bips/blob/master/bip-0137.mediawiki) - simply scheme for message signing that works with P2PKH, P2PSH and bech32
- [BIP-322](https://github.com/kallewoof/bips/blob/master/bip-0322.mediawiki) - reuses Bitcoin script to process a generic signed message format

- [EIP-191](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-191.md) - encode data for Ethereum contracts
- [EIP-712](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md) - encode structs for Ethereum contracts

# Proposal

We propose a scheme that is generic in nature. By that we mean it does not specify a serialization format for the actual data you wish to sign nor does it enforce a specific communication channel between the signer and the validator.

For the encoding, we will use [bech32](https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki) not only because it solves problems (1), (2) and (3) but because it will already be implemented for Cardano starting in Shelley as specified in [CIP-001](https://github.com/input-output-hk/implementation-decisions/blob/master/text/0001-address.md
).

### Brief note on CIP-001 on-chain encoding

CIP-001 tries to minimize on-chain data by neither storing the checksum nor the protocol magic in its encoding. It's up to clients to display the correct bech32 prefix based on the context and not the on-chain data. Instead, it relies on the fact that the Cardano transaction signatures include the protocol magic inside them to avoid replay attacks. This is enough to protect end-users and, in order to protect developers, it also contains a single-bit discriminant that simply encodes testnet vs mainnet.

### Brief note on transaction signing format

Cardano uses [CBOR](http://cbor.io/) for most encoding. You can find a fairly good introduction for how Cardano uses CBOR for the legacy transaction format [here](https://github.com/input-output-hk/cardano-sl/blob/develop/docs/tx/binary-format.md).

All objects with special meaning when signed in Cardano are prefixed by a CBOR tag. For example, transaction signatures are generated by signing the following

```rust
se
  .write_unsigned_integer(SigningTag::Tx as u64)
  .serialize(&protocol_magic)
  .serialize(txid)
```

and these are wrapped in a `witness` (serialization logic [here](https://github.com/input-output-hk/rust-cardano/blob/103d15d2df17f6ffc055f4563da16c206e7ce135/cardano/src/tx.rs#L202))

lastly, an array of witnesses is represented by a fixed-length CBOR array (call this function `FIXED_ARRAY`)

```rust
serializer.write_array(Len::Len(data.len() as u64))?;
for element in data {
    Serialize::serialize(element, serializer)?;
}
```

You can see all existing tags in Rust [here](https://github.com/input-output-hk/rust-cardano/blob/2e924a4457203fa6b19f409cb897d90cd6b699f6/cardano/src/tags.rs) and in Haskell [here](https://github.com/input-output-hk/cardano-sl/blob/ccca8b346413f12e9fad8cab4c855e69669a2151/crypto/Pos/Crypto/Signing/Tag.hs#L15)

### Proposed format

##### Definitions

**Define**: New CBOR tag `MessageTag = 0x0b` to be used for our new message signing standard. This tag is different than all other tags for meaningful signed data inside Cardano.

**Define**: byte array `UserMessage` which is the message the user wishes to sign. It is RECOMMENDED to use unicode with utf8 encoding if the message is a string and RECOMMENDED to use network-byte-order for numbers.

**Define**: function `BASE32` which converts bytes to base32 in the following way

1) Consider byte array as an array of 5-bit values (most significant bit first)
1) 0-pad last item if necessary
1) Translate the array elements using the [bech32 table](https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki#bech32)

**Define**: uint8 `KeyType` which exists so that programming languages can assign the correct type to these keys if needed. Although there is no standard specifying a number for each key type, in practice the following are used

| Type            | ID |
|-----------------|----|
| XPub            | 0  |
| ValidatorScript | 1  |
| RedeemPublicKey | 2  |

**Define**: uint32 `ProtocolMagic` which specifies the chain id. Notably, the `ProtocolMagic` for the Cardano Mainnet is `764824073`

**Define**: function `SIGN` which cryptographically signs data. This function is purposely left vague as the implementation depends on what kind of key is used.

**Define**: uint8 `FormatVersion` which specifies the version number for the proposed format.

**Define**: byte* `Recipient` which is a identifier for who you are signing this message for. This is to avoid replay attacks as dapps for example can specify their contract address as the recipient. It is still not fool-proof as somebody can ask you to sign a message with the recipient set the same as the recipient field of the contract/person they intend to pass your message along to.

##### FormatVersion 1

```
HRP             ::= 'cm'
UserMessage     ::= byte*
MessageTag      ::= 0x0b
ProtocolMagic   ::= uint32
Recipient       ::= byte*
Signature       ::= SIGN(MessageTag || ProtocolMagic || UserMessage)
                  | SIGN(MessageTag || ProtocolMagic || Recipient || UserMessage)

KeyType         ::= uint8
KeyData         ::= byte*
PlainSignature ::= [ KeyType, Signature ]
Witness         ::= [ KeyType, KeyData, Signature ]

Signatures      ::= [ PlainSignature+ ]
Witnesses       ::= [ Witness+ ]
Elements        ::= 0 Signatures
                  | 1 Witnesses

FormatVersion   ::= uint8
RawData         ::= BASE32([ FormatVersion , Elements ])
                  | BASE32([ FormatVersion , Elements, Recipient ])

DATA            ::= RawData CHECKSUM(HRP, RawData)
BECH32          ::= HRP '1' DATA
```

##### Extra details

You MUST encode and decode this format using CBOR (see reference implementation)

It is RECOMMENDED that if you upload a signed message of this format on the blockchain, you simply use `RawData` without checksum, HRP and without `bech32` encoding. This is because these features are intended to avoid human error and facilitate human communication -- something whch isn't requried for on-chain data where space efficiency is more important.

It is RECOMMENDED to include the public key in the witness calculation as

1) It simplifies sending the public key to the verifier if they do not already have the xpub
1) It allows the verifier to check the message is for the key they expect if they already have the xpub
1) It allows to easily pair signatures to xpub in the case of proving ownership of all addresses in a transaction
Notes:

It is RECOMMENDED to save the signatures in the same order as they appear in a transaction if proving ownership of addresses in a transaction (including duplicating a signature if the same xpub appears in the transaction multiple times also)

- Note we don't need a discriminant because out data is always paired with a signature.
- We use `cm` as the Human-Readable Part (HRP) to be similar to the `ca` prefix used by CIP-001
- We allow an array of witnesses to easily be able to prove the ownership of all inputs in a transaction at once
- We allow to optionally not specify the public key. This shrinks the amount of data requried which is important for memory-constrained environments like the blockchain (where you may already know the public key anyway you're asking the user to verify ownership of addresses iin a transaction) or hardware wallets.

It is RECOMMENDED to avoid bip44 public keys unless you never plan to soft-derive from them as it is both a privacy and a security risk (see [here](https://bitcoin.org/en/wallets-guide#hierarchical-deterministic-key-creation) for more detail).

# Test vectors

TODO

# Reference implementation

TODO

# TODO

Is adding `Recipient` to the data you sign enough?
Should `Recipient` also appear as plain text in the data?
